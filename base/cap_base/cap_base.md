
CAP
----------------
CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。  
  
CAP原则是NOSQL数据库的基石。  
  
分布式领域CAP理论：  
C：Consistency (一致性), 数据一致更新，所有数据变动都是同步的  
A：Availability (可用性), 指快速获取数据，好的响应性能  
P：Partition tolerance (分区容错性) 可靠性  
  
定理：任何分布式系统只可同时满足二点，没法三者兼顾。  
忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。  
  
  
CA：传统关系数据库  (sql)  
AP：key-value数据库   (nosql)  
  
  
  
BASE  
----------------
Basically Available（基本可用）  
Soft state（软状态）  
Eventually consistent（最终一致性）  
  
BASE是上面三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果。其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的。
  
其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。  
  
  
接下来我们着重对BASE中的三要素进行详细讲解:   
  
  
基本可用  
  
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。  
  
响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。  
功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。  
  
  
最终一致性  
  
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性  
  
亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍。他认为最终一致性时一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够胡渠道最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素。  
  
  
在实际工程实践中，最终一致性存在以下五类主要变种。  
  
因果一致性：  
  
	因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。  
  
读己之所写：  
  
    读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。  
  
会话一致性：  
  
    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。  
  
单调读一致性：  
  
    单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。  
  
单调写一致性：  
  
    单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。  
  
  
以上就是最终一致性的五类常见的变种，在时间系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。事实上，可以将其中的若干个变种相互结合起来，以构建一个具有最终一致性特性的分布式系统。事实上，最终一致性并不是只有那些大型分布式系统才设计的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多都会采用同步和异步方式来实现主备数据复制技术。在同步方式中，数据的复制国耻鞥通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往存在延时，这取决于事务日志在主备数据库之间传输的时间长短，如果传输时间过长或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么狠显然，从备库中读取的的数据将是旧的，因此就出现了不一致的情况。当然，无论是采用多次重试还是认为数据订正，关系型数据库还是能搞保证最终数据达到一致——这就是系统提供最终一致性保证的经典案例。  
  
总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。  
  
  

关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：  
Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。  
Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。  
Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。  
Durability. 一旦事务完成，就不能返回。  

跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。  
  
BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：  
Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)  
Soft state软状态 状态可以有一段时间不同步，异步。  
Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。  
  
BASE思想的主要实现有：  
1.按功能划分数据库   
2.sharding碎片   
  
  
  

  
选择权衡
---------------
通过上面的例子，我们得知，我们永远无法同时得到CAP这3个特性，那么我们怎么来权衡选择呢？  
选择的关键点取决于业务场景  
  
对于大多数互联网应用来说（如网易门户），因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有设置一致性来保证服务的AP，通常常见的高可用服务吹嘘5个9 6个9服务SLA稳定性就本都是放弃C选择AP  
  
对于需要确保强一致性的场景，如银行，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）  
  
  
  
分布式系统的典型应用
---------------
分布式系统是一个非常广泛的概念，它最终要落实到解决实际问题上，不同的问题有不同的方法和架构。所有的开源软件都是以某个应用场景出现，而纯粹以“分布式”概念进行划分的比较少见。  

但如果以算法划分，到能分出几类：  
1.以Leader选举为主的一类算法，比如paxos、viewstamp，就是现在zookeeper、Chuby等工具的主体  
2.以分布式事务为主的一类主要是二段提交，这些分布式数据库管理器及数据库都支持  
3.以若一致性为主的，主要代表是Cassandra的W、R、N可调节的一致性  
4.以租赁机制为主的，主要是一些分布式锁的概念，目前还没有看到纯粹“分布式”锁的实现  
5.以失败探测为主的，主要是Gossip和phi失败探测算法，当然也包括简单的心跳  
6.以弱一致性、因果一致性、顺序一致性为主的，开源尚不多，但大都应用在Linkedin、Twitter、Facebook等公司内部  
7当然以异步解耦为主的，还有各类Queue  

