

什么是哈希算法？
-------------
哈希算法又叫散列算法，是将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。  
它的原理其实很简单，就是把一段交易信息转换成一个固定长度的字符串。  
  
这串字符串具有一些特点：  
1. 信息相同，字符串也相同。  
2. 信息相似不会影响字符串相同。  
3. 可以生成无数的信息，但是字符串的种类是一定的，所以是不可逆的。  


哈希算法有什么用途？
-------------
哈希算法可以检验信息是否是相同的，这样的优势可以节省重复文件传送的时间。

举一个生活中很平常的例子，我们在生活工作中会使用一些软件给别人传送文件数据，如果有人传送了一份文件给一个人，然后又有一个人传送了相同的文件给了另外一个人，那么这个社交软件在第二次传送文件的时候会对比两次传送的哈希值，发现是相同的，该软件就不会再次上传文件给服务器了。  


除此之外，哈希算法还可以检验信息的拥有者是否真实。  

比如，我们在一个网站注册一个账号，如果网站把密码保存起来，那这个网站不论有多安全，也会有被盗取的风险。但是如果用保存密码的哈希值代替保存密码，就没有这个风险了，因为哈希值加密过程是不不可逆的。  

注意：哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。



哈希算法会不会被破解？
-------------
从理论上说，哈希值是可以被获得的，但是对应的用户密码很难获得。  

假设一个网站被攻破，黑客获得了哈希值，但仅仅只有哈希值还不能登录网站，他还必须算出相应的账号密码。

计算密码的工作量是非常庞大且繁琐的，严格来讲，密码是有可能被破译的，但破译成本太大，被成功破译的几率很小，所以基本是不用担心密码泄露的。

当然，黑客们还可以采用一种物理方法，那就是猜密码。他可以随机一个一个的试密码，如果猜的密码算出的哈希值正好与真正的密码哈希值相同，那么就说明这个密码猜对了。

密码的长度越长，密码越复杂，就越难以猜正确。如果有一种方法能够提高猜中密码的可能，那么可以算是哈希算法被破解了。


比如说，例如原本猜中的概率是1/10000000000000，现在增加到了1/1000。如果每猜一个密码需要1秒，按照之前的概率猜，直到地球毁灭都可能没猜中，但后者只需要1小时就足够了。在这样的情况下，哈希算法就算是被破解啦。

好啦，看到这里你是不是对哈希算法有了初步的了解？大家也不要过于担心你的账户以及资产被黑的风险，因为哈希算法仅仅只是比特币的原理算法，还有其他算法一同作用于比特币的运行，因此就算破解了哈希算法也并不能盗取你的账户信息。


hashtable 是什么？
================
哈希表(hashtable)是一种通过哈希函数，将特定的键映射到特定值的一种数据结构，它维护键和值之间一一对应关系。  

键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。  
槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。  
哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。  
哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。  

哈希表可以理解为数组的扩展或者关联数组，数组使用数字下标来寻址，如果关键字(key)的范围较小且是数字的话， 我们可以直接使用数组来完成哈希表，而如果关键字范围太大，如果直接使用数组我们需要为所有可能的key申请空间。很多情况下这是不现实的。即使空间足够，空间利用率也会很低，这并不理想。同时键也可能并不是数字，在PHP中尤为如此，所以人们使用一种映射函数(哈希函数)来将key映射到特定的域中：
> h(key) -> index  
通过合理设计的哈希函数，我们就能将key映射到合适的范围，因为我们的key空间可以很大(例如字符串key)，在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况，这就是我们所说的出现了冲突。 目前解决hash冲突的方法主要有两种：链接法(拉链法)和开放寻址法。  


哈希冲突解决
================
两种方法：链接法(拉链法)和开放寻址法。  


链接法(拉链法)：PHP使用的就是第二种方法。
-------------
链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表， 这样的话操作链表的时间复杂度则成了O(n)，这样哈希表的性能优势就没有了， 所以选择一个合适的哈希函数是最为关键的。


开放寻址法：当冲突发生的时候，冲突的元素会被保存到一个不同的索引中；
-------------
使用开放寻址法是槽本身直接存放数据，在插入数据时如果key所映射到的索引已经有数据了，这说明发生了冲突，这是会寻找下一个槽，如果该槽也被占用了则继续寻找下一个槽，直到寻找到没有被占用的槽，在查找时也使用同样的策略来进行。  

由于开放寻址法处理冲突的时候占用的是其他槽位的空间,这可能会导致后续的key在插入的时候更加容易出现 哈希冲突，所以采用开放寻址法的哈希表的装载因子不能太高，否则容易出现性能下降。  


注意：装载因子 是哈希表保存的元素数量和哈希表容量的比，通常采用链接法解决冲突的哈希表的装载 因子最好不要大于1，而采用开放寻址法的哈希表最好不要大于0.5。  


hash数据结构：
-------------
首先我们需要一个容器来保存我们的哈希表，哈希表需要保存的内容主要是保存进来的数据，同时为了方便的得知哈希表中存储的元素个数，需要保存一个大小字段， 第二个需要的就是保存数据的容器了。

如下面将实现一个简易的哈希表。基本的数据结构主要有两个，一个用于保存哈希表本身，另外一个就是用于实际保存数据的单链表了，定义如下：
```
typedef struct _Bucket
{
    char *key;
    void *value;
    struct _Bucket *next;
} Bucket;
 
typedef struct _HashTable
{
    int size;
    int elem_num;
    Bucket** buckets;
} HashTable;
```

上面的定义和PHP中的实现类似，为了便于理解裁剪了大部分无关的细节，在本节中为了简化，key的数据类型为字符串，而存储的数据类型可以为任意类型。

Bucket结构体是一个单链表，这是为了解决多个key哈希冲突的问题，也就是前面所提到的的链接法。 当多个key映射到同一个index的时候将冲突的元素链接起来。

1) 扩容：  
由于在插入过程中可能会导致哈希表的元素个数比较多(如陆续朝一个数组中追加新元素)，如果超过了哈希表的容量，则说明肯定会出现碰撞，出现碰撞则会导致哈希表的性能下降，为此如果出现元素容量达到容量则需要进行扩容。 由于所有的key都进行了哈希，扩容后哈希表不能简单的扩容，而需要重新将原有已插入的预算插入到新的容器中。  

哈希表的扩容首先申请一块新的内存，大小为原来的2倍，然后重新将元素插入到哈希表中， 读者会发现扩容的操作的代价为O(n)，不过这个问题不大，因为只有在到达哈希表容量的时候才会进行。


2）查找：  
在查找时也使用插入同样的策略，找到元素所在的位置，如果存在元素，则将该链表的所有元素的key和要查找的key依次对比，直到找到一致的元素，否则说明该值没有匹配的内容。  


PHP中数组是基于哈希表实现的，但是比上面所说要复杂一些。

PHP内核中的哈希表是十分重要的数据结构，PHP的大部分的语言特性都是基于哈希表实现的，例如：变量的作用域、函数表、类的属性、方法等，Zend引擎内部的很多数据都是保存在哈希表中的。  



什么是链表？
-----------
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。   


PHP7中新的Hashtable实现和性能改进  
https://blog.csdn.net/xiaolei1982/article/details/52292866  




















