
参考地址：
------------
https://blog.csdn.net/chuixue24/article/details/80027689


B+Tree
-------------
B+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：

1、有m个子树的节点包含有m个元素（B-Tree中是m-1）

2、根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。

3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。

4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。

注意：
通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。  

因此可以对B+Tree进行两种查找运算：
一种：是对于主键的范围查找和分页查找。  
另一种：是从根节点开始，进行随机查找。  



B+Tree优点总结：
-------------
1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。  
2.所有查询都要查找到叶子节点，查询性能稳定。   
3.所有叶子节点形成有序链表，便于范围查询。   

PS:
在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。  
在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。    




B+树索引演化历史
===========
B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。

演变历史：  
二叉查找树(btree)  -> 平衡二叉树(AVLTree)  平衡多路查找树(B-Tree) -> B+tree -> B*tree  


1) 二叉查找树或二叉搜索树  
---------
二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。 
```
     6
   /   \
  3      7
 / \      \
2   5      8
```
对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次

二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：
```
   2
     \
      3
        \
         5
          \
           7
          / \
         6   8  
```
但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。



2) 平衡二叉树（AVL Tree）
---------  
平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。如下：它的任何节点的两个子树的高度差<=1；
```
         5
      /     \
     2       8
    / \     /
   1   4   7
      / 
     3
```
如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。

这四种失去平衡的姿态都有各自的定义： 
LL：LeftLeft，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。

RR：RightRight，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。  

LR：LeftRight，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。  

RL：RightLeft，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。  

AVL树失去平衡之后，可以通过旋转使其恢复平衡。下面分别介绍四种失去平衡的情况下对应的旋转方法。

1）LL的旋转。LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：  
	将根节点的左孩子作为新根节点。  
	将新根节点的右孩子作为原根节点的左孩子。  
	将原根节点作为新根节点的右孩子。  

2）RR的旋转：RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：  
	将根节点的右孩子作为新根节点。  
	将新根节点的左孩子作为原根节点的右孩子。  
	将原根节点作为新根节点的左孩子。  

3）LR的旋转：LR失去平衡的情况下，需要进行两次旋转，步骤如下：  
	围绕根节点的左孩子进行RR旋转。  
	围绕根节点进行LL旋转。  

4）RL的旋转：RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：  
	围绕根节点的右孩子进行LL旋转。  
	围绕根节点进行RR旋转。  



平衡多路查找树（B-Tree）
------------
B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
> mysql> show variables like 'innodb_page_size';

而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。  

B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一棵 m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子  
4. 所有叶子节点都在同一层，且不包含其它关键字信息   
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）   
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1   
7. ki(i=1,…n)为关键字，且关键字升序排序。   
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

注：
键值k，即表中记录的主键    
指针p，存储子节点地址信息  
数据data，即表记录中除主键外的数据  

```
一个3阶B-Ttee

       磁盘块1 p1  17+data    p2    35+data                 p3
            /                 \                              \
块2 p1 8+data p2 12+data p3    块3 p1 26+data p2 30+data p3   块4 p1 26+data p2 30+data p3 
         
磁盘块5 3+data 5+data  磁盘块6 9+data 10+data  磁盘块7 13+data 15+data

```  
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键字划分成的三个范围域对应三个指针指向的子树的数据的范围域。  
以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。  

模拟查找关键字5的过程：
```
1) 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2) 比较关键字5在区间（,17），找到磁盘块1的指针P1。
3) 根据P1指针找到磁盘块2，读入内存。【磁盘I/O操作第2次】
4) 比较关键字5在区间（,8），找到磁盘块3的指针P1。
5) 根据P1指针找到磁盘块5，读入内存。【磁盘I/O操作第3次】
6) 在磁盘块5中的关键字列表中找到关键字5。
```

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。  

在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：
```
BTree_Search(node, key)
{
    if(node == null) returnnull;
 
    foreach(node.key)
    {
        if(node.key[i] == key) returnnode.data[i];
        if(node.key[i] > key) returnBTree_Search(point[i]->node);
    }
 
    returnBTree_Search(point[i+1]->node);
}
 
data = BTree_Search(root, my_key);
```



B+Tree
---------------
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：
  1) B+tree非叶子节点只存储键值信息。  
  2) B+tree所有叶子节点之间都有一个链指针。  
  3) B+tree数据记录或数据地址都存放在叶子节点中。  


B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 
```
                       磁盘块1
	                 p1 28 p2 空k 空p 空k 空p 空k 空p
	                 /       \  
               磁盘块2         磁盘块3
       p1 10 p2 17 p3         p1 36 p2 79 p3
       /      |        \         \
  磁盘块4 <->  磁盘块5 <-> 磁盘块6 <-> ...
 3 5 9 10   10 12 13 15   17 26     ...
 d d d d    d  d  d  d    d   d     ...

注：该图中用d表示的是data数据

如果是复合索引，则结构是这样的
磁盘块1
p1 ('列1的值','列2的值', ...) p2 ('列1的值','列2的值', ...) p3
```
b+tree对任何节点的查询都需要n次(为b+tree的高度)，因为要找到叶子节点    

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。  
因此可以对B+Tree进行两种查找运算：
一种：是对于主键的范围查找和分页查找。  
另一种：是从根节点开始，进行随机查找。  

可能上面例子中只有有限条数据记录，看不出B+Tree的优点，下面做一个推算：  

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为 10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。  

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。  

数据库中的B+Tree索引可以分为聚集索引（clustered index）和 辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。  

注意区分：
myisam中是非聚集索引，叶子节点存的是真实数据行的地址而没有直接存行数据。
innodb中分聚集索引（clustered index）和 辅助索引（secondary index）。



B*树
---------
B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；



























































