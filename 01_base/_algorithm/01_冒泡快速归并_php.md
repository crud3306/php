
冒泡 时间复杂度：O(n平方)  
快速 时间复杂度：Ο(nlogn)  
插入 时间复杂度：Ο(n平方)  
选择 时间复杂度：Ο(n平方)  
堆  时间复杂度：Ο(nlogn)  
归并 时间复杂度：Ο(nlogn)  
希尔 时间复杂度：Ο(n平方)  

稳定性定义：排序前后两个相等的数相对位置不变，则算法稳定。

稳定性得好处：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。

各排序算法的稳定性：

1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；

2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。



一、冒泡排序
---------------
1、小的元素往前调或者把大的元素往后调；

2、比较是相邻的两个元素比较，交换也发生在这两个元素之间；

3、稳定排序算法。



二、快速排序
---------------
1、两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]；

2、如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j；

3、交换a[j]和a[center_index]，完成一趟快速排序；

4、在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱；

5、不稳定发生在中枢元素和a[j] 交换的时刻；

6、不稳定的排序算法。


三、选择排序
---------------
1、每个位置选择当前元素最小的；

2、在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了；

3、举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了；

4、不稳定的排序算法。



四、插入排序
---------------
1、已经有序的小序列的基础上，一次插入一个元素；

2、想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置；

3、如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面；

4、相等元素的前后顺序没有改变；

5、稳定排序算法。



五、归并排序
---------------
1、把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序；

2、合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性；

3、稳定排序算法。



六、希尔排序(shell)
---------------
1、按照不同步长对元素进行插入排序；

2、当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；

3、当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高；

4、所以，希尔排序的时间复杂度会比o(n^2)好一些

由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱；

5、不稳定的排序算法。



七、基数排序
---------------
1、按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位；

2、有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前；

3、用于整数；

4、需要较多的存储空间；

5、基于分别排序，分别收集；

6、稳定排序算法。



八、堆排序
---------------
1、是选择排序的一种；

2、堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点，是完全二叉树；

3、在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了；

4、不稳定的排序算法。




冒泡排序
====================
冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，依次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

时间复杂度：O(n*n) 即： O(n的平方). 
步骤：
-------------------------------
比较相邻的元素。如果第一个比第二个大，就交换他们两个。  
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  
针对所有的元素重复以上的步骤，除了最后一个。  
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  

具体代码：
-------------------------------
```php
$arr=array(1,43,54,62,21,66,32,78,36,76,39);
function bubbleSort ($arr)
{
     $len = count($arr);

     //该层循环控制 需要冒泡的轮数
     for ($i=1; $i<$len; $i++) {

          $has_change = false;

          //该层循环用来控制每轮 冒出一个数 需要比较的次数
          for ($k=0; $k<$len-$i; $k++) {
               if($arr[$k] > $arr[$k+1]) {
                    $tmp = $arr[$k+1]; // 声明一个临时变量
                    $arr[$k+1] = $arr[$k];
                    $arr[$k] = $tmp;

                    $has_change = true;
               }
          }

          if (!$has_change) {
            break;
          }
     }
     return $arr;
}
```




快速排序
====================
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。

时间复杂度：Ο(nlogn)

步骤：
--------------------------------
从数列中挑出一个元素，称为 “基准”（pivot），
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

具体代码：
---------------------------------
```php
function quick_sort($arr)
{
     //递归出口:数组长度为1，直接返回数组
     $length = count($arr);
     if ($length <= 1) {
        return $arr;
     }

     //数组元素有多个,则定义两个空数组
     $left = $right = array();
     //使用for循环进行遍历，把第一个元素当做比较的对象
     for ($i = 1; $i < $length; $i++)
     {
          //判断当前元素的大小
          if ($arr[$i] < $arr[0]) {
               $left[] = $arr[$i];
          } else {
               $right[] = $arr[$i];
          }
     }

     //递归调用
     $left = quick_sort($left);
     $right = quick_sort($right);

     //将所有的结果合并，这样是升序
     return array_merge($left, array($arr[0]), $right);
     // 这就就是降序了
     // return array_merge($right, array($arr[0]), $left);
}


// 不借助输助空间
function quickSort(a,left,right){
    if(left==right)return;
    let index=partition(a,left,right);//选出key下标

    if(left<index){
        quickSort(a,left,index-1);//对key的左半部分排序
    }
    if(index<right){
        quickSort(a,index+1,right)//对key的右半部份排序
    }
}
function partition(a,left,right){
    let key=a[left];//一开始让key为第一个数
    while(left<right){//扫描一遍
        while(key<=a[right]&&left<right){//如果key小于a[right]，则right递减，继续比较
            right--;
        }
        [a[left],a[right]]=[a[right],a[left]];//交换

        while(key>=a[left]&&left<right){//如果key大于a[left]，则left递增，继续比较
            left++;
        }
        [a[left],a[right]]=[a[right],a[left]];//交换
        
    }
    return left;//把key现在所在的下标返回
}
```

性能优化分析：   
该算法是通过分治递归来实现的，其效率很大程度上取决于参考元素的选择，可以选择数组的中间元素，也可以随机得到三个元素，然后选择中间的那个元素（三数中值法）。   
另外还有一点，就是当我们在分割时，如果分割出来的子序列的长度很小的话（小于5到20），通常递归的排序的效率就没有诸如插入排序或希尔排序那么快了。因此可以会去判断数组的长度，如果小于10的话，直接用插入排序，而不再递归调用这个快速排序。  


注：【冒泡排序】 和 【快速排序】 规属为 【交换排序】


插入排序
====================
插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。  
它的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。  

时间复杂度：O(n*n) 即： O(n的平方)   

步骤：
```
1) 从第一个元素开始，该元素可以认为已经被排序  
2) 取出下一个元素（新元素），在已经排序的元素序列中从后向前扫描   
3) 如果扫描到的元素（已排序的元素）大于新元素，将该元素移到下一位置  
4) 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置  
5) 将新元素插入到该位置中  
6) 重复步骤2  
```
具体代码：
```php
function insert_sort($arr)
{
    $len=count($arr);

    for($i=1; $i<$len; $i++) {
        //获得当前需要比较的元素值。
        $tmp = $arr[$i];

        //内层循环控制 比较 并 插入
        for ($j=$i-1; $j>=0; $j--) {

            //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素
            if ($tmp < $arr[$j]) {
                //发现插入的元素要小，交换位置
                //将后边的元素与前面的元素互换
                $arr[$j+1] = $arr[$j];
                //将前面的数设置为 当前需要交换的数
                $arr[$j] = $tmp;

            } else {
                //如果碰到不需要移动的元素
                //由于是已经排序好是数组，则前面的就不需要再次比较了。
                break;
            }
        }
    }

    return $arr;
}
```



选择排序
====================
选择排序(Selection sort)是一种简单直观的排序算法。  
它的工作原理如下：每次找出最大的元素的位置，然后和最后一位元素更换。  
或者：每次找出最小的元素的位置，然后和第一位元素更换。  

时间复杂度：O(n*n) 即： O(n的平方) 

具体代码：
```php
//实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数
function select_sort($arr) 
{
     //$i 当前最小值的位置， 需要参与比较的元素
     for($i = 0, $len = count($arr); $i < $len-1; $i++) {
          //先假设最小的值的位置
          $p = $i;

          //$j 当前都需要和哪些元素比较，$i 后边的。
          for ($j=$i+1; $j<$len; $j++) {
               //$arr[$p] 是 当前已知的最小值
               if($arr[$p] > $arr[$j]) {
                    //比较，发现更小的,记录下最小值的位置；
                    //并且在下次比较时，应该采用已知的最小值进行比较。
                    $p = $j;
               }
          }

          //已经确定了当前的最小值的位置，保存到$p中。
          //如果发现 最小值的位置与当前假设的位置$i不同，则位置互换即可
          if ($p != $i) {
               $tmp = $arr[$p];
               $arr[$p] = $arr[$i];
               $arr[$i] = $tmp;
          }
     }

     //返回最终结果
     return $arr;
}
```


堆排序 （最大堆/最小堆）
====================
堆排序求升序用大顶堆，求降序用小顶堆。

本例用求降序的小顶堆来解析。

时间复杂度：Ο(nlogn)

堆排序步骤如下：
----------
1、我们将数据（49、38、65、97、76、13、27、50）建立一个数组$arr；
2、用数组$arr建立一个小顶堆（主要步骤，会在代码注释里解释，下图是用一个数组建立小顶堆的过程）；
3、将堆的根（最小的元素）与最后一个叶子交换，并将堆长度减一，跳到第二步；
4、重复2-3步，直到堆中只有一个结点，排序完成。

实现：
```php
//因为是数组,下标从0开始,所以,下标为n根结点的左子结点为2n+1,右子结点为2n+2;  
//初始化值,建立初始堆

$arr=array(49,38,65,97,76,13,27,50);
$arrSize=count($arr);

//将第一次排序抽出来，因为最后一次排序不需要再交换值了。
buildHeap($arr, $arrSize);

for($i=$arrSize-1; $i>0; $i--){
    swap($arr,$i,0);
    $arrSize--;
    buildHeap($arr,$arrSize);   
}

//用数组建立最小堆
function buildHeap(&$arr,$arrSize){
    //计算出最开始的下标$index,如图,为数字"97"所在位置,比较每一个子树的父结点和子结点,将最小值存入父结点中
    //从$index处对一个树进行循环比较,形成最小堆
    for($index=intval($arrSize/2)-1; $index>=0; $index--){
        //如果有左节点,将其下标存进最小值$min
        if($index*2+1 < $arrSize){
            $min=$index*2+1;

            //如果有右子结点,比较左右结点的大小,如果右子结点更小,将其结点的下标记录进最小值$min
            if($index*2+2<$arrSize){
                if($arr[$index*2+2]<$arr[$min]){
                    $min=$index*2+2;
                }
            }

            //将子结点中较小的和父结点比较,若子结点较小,与父结点交换位置,同时更新较小
            if($arr[$min]<$arr[$index]){
                swap($arr,$min,$index);
            }   
        }
    }
}

//此函数用来交换下数组$arr中下标为$one和$another的数据
function swap(&$arr,$one,$another){
    $tmp=$arr[$one];
    $arr[$one]=$arr[$another];
    $arr[$another]=$tmp;
}
```


希尔排序
=====================
基本思想：  
希尔排序是指记录按下标的一定增量分组，对每一组使用 直接插入排序 ，随着增量逐渐减少，每组包含的关键字越来越多，当增量减少至 1 时，整个序列恰好被分成一组，算法便终止。

操作步骤：  
先取一个小于 n（序列记录个数） 的整数d1作为第一个增量，把文件的全部记录分组。所有距离为 d1 的倍数的记录放在同一个组中。先在各组内进行 直接插入排序；然后，取第二个增量 d2 < d1 重复上述的分组和排序，直至所取的增量 dt=1( dt < d(t-1) …< d2 < d1)，即所有记录放在同一组中进行 直接插入排序 为止.  
```php
<?php
//希尔排序(对直接插入排序的改进)
function ShellSort(array &$arr)
{
  $count = count($arr);
  $inc = $count;  //增量
  do {
    //计算增量
    //$inc = floor($inc / 3) + 1;
    $inc = ceil($inc / 2);
    for ($i = $inc; $i < $count; $i++) {
      $temp = $arr[$i];  //设置哨兵
      //需将$temp插入有序增量子表
      for ($j = $i - $inc; $j >= 0 && $arr[$j + $inc] < $arr[$j]; $j -= $inc) {
        $arr[$j + $inc] = $arr[$j]; //记录后移
      }
      //插入
      $arr[$j + $inc] = $temp;
    }
    //增量为1时停止循环
  } while ($inc > 1);
}
//$arr = array(9,1,5,8,3,7,4,6,2);
$arr = array(49,38,65,97,76,13,27,49,55,04);
ShellSort($arr);
var_dump($arr);
```


归并排序
=====================
归并排序
归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

时间复杂度：Ο(nlogn)

归并过程.  
归并排序的核心就是如何将两个有序序列进行合并，假定有两个有序数组，比较两个有序数组的首个元素，谁小就取谁，并将该元素放入第三个数组中，取了之后在相应的数组中将删除此元素，依次类推，当取到一个数组已经没有元素时，就可将另一数组的剩余元素直接添加到第三个数组中。

原理. 
1、将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两个元素,最后一个序列可能只有一个元素。
2、将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四个元素，最后一个序列可能只有三个及以下元素。
3、重复步骤2，直到所有元素排序完毕。
```php
<?php
function merge_sort($arr){
  $length=count($arr);
  if($length<=1){
    return $arr;
  }

  //分解数组，递归排序
  $half=ceil($length/2);
  $arr2=array_chunk($arr, $half);
  $left=merge_sort($arr2[0]);
  $right=merge_sort($arr2[1]);

  while(count($left) && count($right)){
    if ($left[0]<$right[0]) {
      $reg[]=array_shift($left);
    } else {
      $reg[]=array_shift($right);
    }
  }
  return array_merge($reg, $left, $right);
}
```

bitmap排序
==========
本文实例讲述了PHP实现bitmap位图排序求交集的方法。分享给大家供大家参考，具体如下：

初始化一串全为0的二进制;  
现有一串无序的整数数组;   
如果整数x在这个整数数组当中，就将二进制串的第x位置为1;  
然后顺序读取这个二进制串,并将为1的位转换成整数,顺序存放到新的集合中,就是排好序的了. 
```php
<?php
function sort()
{
    // var_dump(PHP_INT_MAX, PHP_INT_SIZE);
    // int 9223372036854775807
    // int 8
    $bitmap = array_fill(0, 50, 0); //申请一个整形数组, 50个元素, 初始化为整数0
    $int_bit_size = PHP_INT_SIZE * 8; //$bitmap中每个整形的二进制位数 (本例中int = 8*8 = 64bit; $bitmap数组一共50*64 = 3200个bit位),也就是说能为最大值小于等于3200的整数集合排序
    
    $a = array(1,4,3,50,34,60,100,88,200,150,300); //定义一个乱序的数组
    
    //扫描$a中的每一个数, 将其转换为 x*64 + y
    foreach ($a as $k => $v) {
      $shang = $v / $int_bit_size;
      $yushu = $v % $int_bit_size;
      $offset = 1 << $yushu;
      $bitmap[$shang] = $bitmap[$shang] | $offset;//将bit位置为1
    }
    
    //将$bitmap中的bit位依次还原为整数输出,即可得到排序后的数组
    $b = array();
    foreach ($bitmap as $k => $v) {
      for ($i = 0; $i < $int_bit_size; $i++) {
        $tmp = 1 << $i;
        $flag = $tmp & $bitmap[$k];
        // $b[] = $flag ? $k * $int_bit_size + $i : false;
        if ($flag) {
          $b[] = $k * $int_bit_size + $i;
        }
      }
    }
    var_dump($b);exit;
}
输出：
array
  0 => int 1
  1 => int 3
  2 => int 4
  3 => int 34
  4 => int 50
  5 => int 60
  6 => int 88
  7 => int 100
  8 => int 150
  9 => int 200
  10 => int 300
```



顺序查找（数组里查找某个元素）
=====================
```
function seq_sch($array, $k)
{   
   for($i=0; $i<$n; $i++){
      if ($array[$i] == $k){
         return $i;
      }
   }

  return -1;
}
```


二分查找，也叫做折半查找（仅适用于事先已经排好序的顺序表）  
排好序的数组里查找某个元素
=====================
```php
<?php
循环遍历：
function getValue($value, $array)
{
    $start = 0;
    $end = count($array);
    while ($start <= $end) {
        $middle = floor(($start + $end) / 2);
        if ($value == $array[$middle]) {
            return $middle + 1;
        } else if ($value > $array[$middle]) {
            $start = $middle + 1;
        } else {
            $end = $middle - 1;
        }
    }
    return -1;
}
    
递归实现：
function getValue2($value, $start, $end, $array)
{
    if ($start <= $end) {
        $middle = floor(($start + $end) / 2);
        if ($value == $array[$middle]) {
            return $middle + 1;
        } else if ($array[$middle] < $value) {
            return getValue2($value, $middle + 1, $end, $array);
        } else if ($array[$middle] > $value) {
            return getValue2($value, $start, $middle - 1, $array);
        }
    }
    return -1;
}
```
