1 赋值运算符函数
===============


2 单例模式
===============



3 数组中重复的数字
===============



4 二维数组中的查找
===============



5 替换空格
===============



6 从尾到头打印链表
===============


7 重建二叉树
===============


8 二叉树的下一个节点
===============



9 两个栈实现队列
===============



10 斐波那契数列
===============


11 旋转数组的最小数字
===============
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
例如：数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1

方法1：一次遍历
方法2：二分查找


12 矩阵中的路径
===============


13 机器人的运动范围
===============



14 剪绳子
===============



15 二进制中1的个数
===============
输入一个整数，输出该数二进制表示中1的个数。
例如：把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出2。

思路：位运算，但要考虑负数问题，会进入死循环。



16 数值的整数次方（快速幂） a的x次方
===============
实现double power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

需考虑指数为负数的问题（求倒），及求倒时分母为0的问题

方法1：循环exponent，base自乘。

方法2：借助位运算，快速幂



17 打印从1到最大的n位数
===============
输入数字n，按顺序打印出从1到最大的n位十进制数。
例如：输入3，则打印出1，2，3一直到最大的3位数999。

需要考虑数字n过大时溢出问题
```php
function print1toMax($n)
{
	$number = 1;
	$i = 0;
	while ($i++ < $n) {
		number *= 10;
	}

	for ($i = 1; $i < $number; ++$i) {
		var_dump($i);
	}
}
```


18 删除链表的节点
===============
在O(1)时间内删除除链表节点
---------------
给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。

思考：正常的要删除，需先遍历找到该节点，再更改该节点的next指针。时间复度为O(n)





19 正则匹配
===============
请实现一个函数用来匹配包含'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次(含0次)。
例如：字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*ab*"不匹配



20 表示数值的字符串
===============
实现一个函数用来判断字符串是否表示数值(包括整数和小数)。
例如：字符串"+100"，"5e2"，"-123"，"3.1416"及"-1E-16"都表示数值，但"12e"、"1a3.14"、"12e+5.4"都不是。



21 调整数组顺序使奇数位于偶数前面
===============
输入一整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

方法1：分出奇数与偶数，然后再连接。需借助辅助空间。

方法2：两个指针，一个指头，一个指尾。如果1指针是偶，2指针是奇，则交换位置。继续移动指针。



22 链表中倒数第k个节点
===============
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如：一个链表6个节点，从头节点开始，它们的值依次是1,2,3,4,5,6。这个链表的倒数第3个节点是值为4的节点。

思路：两个指针，一个先走k步，然后两针同时走，当第一个指针走到末尾时，第二个指针指向的节点即是我们需要的值。
```

```


23 链表中环的入口节点
===============
如果一个链表中包含环，如何找出环的入口节点？

第一步：确定链表是否包含环。两个指指，一个指针一次走一步，另一个指针一次走两步。如果走的快的追上了走的慢的，则存在环。

第二步：两个指针指向头节点，如果链表有n个节点，则指针p1先在链表上移动n步，然后两个指针同速前进。


24 反转链表
===============
输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
```

```


25 合并两个排序的链表
===============
输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
```php
class Node {
	public $value = null;
	public $next = null;
}

function mergeList(&$head1, &$head2)
{
	if ($head1->value == null) {
		return $head2;
	}
	if ($head2->value == null) {
		return $head1;
	}

	$pMergeHead = new Node();
	if ($head1->value < $head2->vaule) {
		$pMergeHead->value = $head1->value;
		$pMergeHead->next = merge($head1->next, $head2);
	} else {
		$pMergeHead->value = $head2->value;
		$pMergeHead->next = merge($head1, $head2->next);
	}

	return $pMergeHead;
}
```



26 树的子结构
===============
输入两棵二叉树a和b，判断b是不是a的子结构。

思考：遍历二叉对a，找节点值与树b根结点一样的节点。

```php
function hasSubtree($root1, $root2)
{
	$result = false;

	if ($root1->value != null && $root2->value != null) {

	}
}
```


27 二叉树的镜像
===============
请完成一个函数，输入一棵二叉树，该函数输出它的镜像。
```
function mirror(&$root)
{
	if ($root->vaule == null) {
		return null;
	}

	$tmp = $root->left;
	$root->left = $root->right;
	$root->right = $tmp;

	if ($root->left != null) {
		mirror($root->left);
	}

	if ($root->right != null) {
		mirror($root->right);
	}
}
```


28 对称二叉树
===============
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一查二叉树和它的镜像一样，那么它是对称的。

```php
function isSymmetrical($root1, $root2)
{
	if ($root1->value == null && $root2->value == null) {
		return true;
	}

	if ($root1->value == null || $root2->value == null) {
		return false;
	}

	if ($root1->value != $root2->value) {
		return false;
	}

	return isSymmetrical($root1->left, $root2->right) && isSymmetrical($root1->right, $root2->left);
}
```


29 顺时针打印矩阵
===============
输入一个短阵，按照从处向里以顺时针的顺序依次打印出每个数字。




