
mysql方面的：
===========

Mysql的日志包括如下几种日志：
-----------
错误日志  
普通查询日志  
二进制日志  
慢查询日志  

```
错误日志 error log
Mysql错误日志主要记录Mysql实例每次启动、停止的详细信息，以及Mysql实例运行过程中产生的警告或者错误信息，与其它日志不同，Mysql错误日志必须开启，无法关闭。 
与错误日志相关的参数： 
log_error：设置了错误日志文件的物理位置。

普通查询日志 general log
Mysql general log记录了Mysql运行的所有操作，无论这些操作执行成功与否。另外还包括一些事件，例如客户端连接断开的一些信息，默认不开启。 
与general log相关的参数： 
general_log=on/off；设置general log是否开启。

慢日志 slow query log
慢日志记录执行时间过程和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。 
与慢日志相关的参数： 
slow_query_log：设置慢日志是否开启。

二进制日志 binlog
二进制日记记录数据库的变化情况，内容报错数据库所有的更新操作，ddl和dml。数据库管理员可以通过二进制日志查看数据库过去某一时刻发生了哪些变化，必要时可以使用二进制日志恢复数据库。二进制文件内容为二进制信息，不可直接查看。
```




请简述数据库设计的范式及应用。
------------
一般第3范式就足以，用于表结构的优化，这样做既可以避免应用程序过于复杂同时也避免了SQL语句过于庞大所造成系统效率低下。

第一范式：若关系模式R的每一个属性是不可再分解的。  

第二范式：在第一范式的基础上更进一层，且所有的非码属性都完全函数依赖于码属性。

第三范式：在第二范式的基础上更进一层，确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，不能存在传递依赖)。

```
第一范式:确保每列的原子性(强调的是列的原子性，即列不能够再分成其他几列).
    如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式.
    例如:顾客表(姓名、编号、地址、……)其中"地址"列还可以细分为国家、省、市、区等。
 
 
第二范式:在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关(一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的部分)
    如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式.
    例如:订单表(订单编号、产品编号、定购日期、价格、……)，"订单编号"为主键，"产品编号"和主键列没有直接的关系，即"产品编号"列不依赖于主键列，应删除该列。
 
第三范式:在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，不能存在传递依赖).
    如果一个关系满足第二范式,并且除了主键以外的其它列都不依赖于主键列,则满足第三范式.
    为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，
依赖A-〉C是传递依赖。
    例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列"订单编号"相关，再细看你会发现"顾客姓名"和"顾客
编号"相关，"顾客编号"和"订单编号"又相关，最后经过传递依赖，"顾客姓名"也和"订单编号"相关。为了满足第三范式，应去掉"顾客姓名"列，放入客户表中。
```



1. Mysql 中，int(1) 和 int(10) 的区别
------------
```
BIT[M]位字段类型，M 表示每个值的位数，范围从 1 到 64，如果 M 被忽略，默认为1

TINYINT [(M)] [UNSIGNED] [ZEROFILL] M 默认为4。很小的整数。
占1字节
带符号的范围是 -128 到 127 。
无符号的范围是0到255。

SMALLINT[(M)] [UNSIGNED] [ZEROFILL] M 默认为6。小的整数。
占2字节
带符号的范围是-32768到32767。
无符号的范围是0到65535。

MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] M 默认为9。中等大小的整数。
占3字节
带符号的范围是-8388608到8388607。
无符号的范围是0到16777215。

INT[(M)] [UNSIGNED] [ZEROFILL] M 默认为11。普通大小的整数。
4字节
带符号的范围是-2147483648到2147483647。
无符号的范围是0到4294967295。

BIGINT[(M)] [UNSIGNED] [ZEROFILL] M 默认为20。大整数。
8字节
带符号的范围是-9223372036854775808到9223372036854775807。
无符号的范围是0到18446744073709551615。
```

注意：这里的 M 代表的并不是存储在数据库中的具体的长度，以前总是会误以为 int(3) 只能存储 3 个长度的数字，int(11) 就会存储 11 个长度的数字，这是大错特错的。其实当我们在选择使用 int 的类型的时候，不论是 int(3)还是 int(11)，它在数据库里面存储的都是4个字节的长度，在使用 int(3)的时候如果你输入的是10，会默认给你存储位 010 ,也就是说这个 3 代表的是默认的一个长度，当你不足 3 位时，会帮你不全，当你超过3位时，就没有任何的影响。

int(M) M 指示最大显示宽度。最大有效显示宽度是255。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。



varchar(10) 与 char(10) 区别
-----------
扩号里的数据表示可存字符个数，不论是数字、字母还是中文。  
> 注：5.0版本以上表示的字符个数，4.0以前的表示字节个数。  

char 定长，长度固定，
varchar变长，即长度可变。
varchar的开头预留1-2字节需存字符的长度，长度小于255用1字节，大于255用2字节




扩展说明字符、字节、位分别是什么及它们的关系：  

1）字符：  
每一个汉字或者字母等等只要是一个单独存在的都看作一个字符，“文”，“1”，“，”等等每一个个体就是一个字符。  

2）字节:  
我们能够看到字节（Byte /bait/ n. [C]）是计算机信息技术用于计量存储容量的一种计量单位。  
字符和字节 在不同的编码格式下，有不同的换算方式。   

3）位: 数据存储的最小单位，  
1字节= 8位   
0000 0000  


mysql的varchar最大有多个字符
-----------
要先明白：MySQL要求一个行定义长度不能超过65535个字节，不包括text、blob等大字段类型，varchar长度受此长度限制，和其他非大字段加起来不能超过65535个字节.

varchar(n)占用几个字节跟字符集有关系：    
由字符集来确定，字符集分单字节和多字节  
```
Latin1 一个字符占一个字节，最多能存放 65532 个字符  
GBK 一个字符占两个字节， 最多能存 32766 个字符  
UTF8 一个字符占三个字节， 最多能存 21844 个字符  
utf8mb4_general_ci  一个字符占四个字节， 最多能存 16383 个字符  
```

注意：char 和 varchar 后面的长度表示的是字符的个数，而不是字节数。  

```
CREATE TABLE `t` (                   
  `var` varchar(21844) default NULL   
) ENGINE=InnoDB DEFAULT CHARSET=utf8
上面的可正常


CREATE TABLE `t` (                   
  `var` varchar(21845) default NULL   
) ENGINE=InnoDB DEFAULT CHARSET=utf8
执行有错误
[Err] 1118 - Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs
```


```
举两个例说明一下实际长度的计算。

a) 若一个表只有一个varchar类型，如定义为

create table t4(c varchar(N)) charset=gbk;
则此处N的最大值为(65535-1-2)/2= 32766 个字符。

	减1的原因是实际行存储从第二个字节开始;  
	减2的原因是varchar头部的2个字节表示长度;  
	除2的原因是字符编码是gbk。  


b) 若一个表定义为

create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8;
则此处N的最大值为 (65535-1-2-4-30*3)/3=21812

	减1和减2与上例相同;  
	减4的原因是int类型的c占4个字节;  
	减30*3的原因是char(30)占用90个字节，编码是utf8。  

如果被varchar超过上述的b规则，被强转成text类型，则每个字段占用定义长度为11字节，当然这已经不是“varchar”了。  

则此处N的最大值为 (65535-1-2-4-30*3)/3=21812

可以通过建表语句验证  
create table t4(c int, c2 char(30), c3 varchar(21812)) ENGINE=InnoDB DEFAULT CHARSET=utf8
```




PHP如何防止sql注入
-----------
php端接收参数过滤，过滤特殊字符    
关闭错误输出，记入log中  
mysql预处理(最佳方式)  
另外还有addslashes() + stripslashes()  

mysql预处理的执行原理是：  
先预发送一个sql模板过去，  
再向mysql发送需要查询的参数，  
就好像填空题一样，不管参数怎么注入，mysql都能知道这是变量，不会做语义解析，起到防注入的效果，这是在mysql中完成的。  



请说出mysql常用存储引擎？memory存储引擎的特点？  
-----------
Myisam、  
InnoDB、  
memory、  
ARCHIVE、  
...
通过执行SHOW ENGINES;可以查看全部，其中support字段为yes的即为当前库支持的存储引擎，为default为默认引擎。  
memory的特点是将表存到内存中，数度快，重启后数据丢失   


myisam与innodb的区别及选择
-----------
区别：

InnoDB:  
	支持事务  
	支持行锁  
	支持外键  
	不支持FULLTEXT类型的索引  
	InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行  
	存储文件位置不同  
		> .frm文件：存储数据表的框架结构  
		> .ibd文件  
	清空整个表时，是一行一行的删除，效率较慢  

myisam:  
	不支持事务  
	表锁  
	不支持外键  
	支持FULLTEXT类型的索引
	MyISAM保存表的行数，只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表    
	存储文件位置不同  
		> .frm文件：存储数据表的框架结构  
		> .MYD文件：即MY Data，表数据文件    
		> .MYI文件：即MY Index，索引文件    
	清空表时，先drop表，然后重建表  



选择：  

因为MyISAM相对简单所以在效率上要优于InnoDB。如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。 

如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。 

两种类型都有自己优缺点，选择那个完全要看自己的实际类弄。  



索引创建的优缺点：
-----------
优点：
创建索引可以大大提高系统的性能  
通过唯一性索引，可以保证数据库表中每一行数据的唯一性  
大大加快检索速度  
加速表与表之间的连接  
使用分组和排序子句进行数据检索时，减少查询中分组和排序的时间  
通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统性能  

缺点：  
创建索引和维护索引要耗费时间，随数据量的增加而增加  
索引占用物理空间  
对表中的数据进行增删改的时候，索引需动态维护，降低了数据的维护速度  


创建索引原则
------------




请描述一下 mysql 主从服务器之间是如何同步数据的，什么样的 sql 会造成主从无法正确同步？
-------------
网络的延迟  
由于 mysql 主从复制是基于 binlog 的一种异步复制，通过网络传送 binlog 文件，理所当然网络延迟是主从不同步的绝大多数的原因，特别是跨机房的数据同步出现这种几率非常的大，所以做读写分离，注意从业务层进行前期设计。  

主从两台机器的负载不一致  
由于 mysql 主从复制是主数据库上面启动1个 io 线程，而从上面启动1个 sql 线程和1个 io 线程，当中任何一台机器的负载很高，忙不过来，导致其中的任何一个线程出现资源不足，都将出现主从不一致的情况。  

max_allowed_packet 设置不一致  
主数据库上面设置的 max_allowed_packet 比从数据库大，当一个大的 sql 语句，能在主数据库上面执行完毕，从数据库上面设置过小，无法执行，导致的主从不一致。

key 自增键开始的键值跟自增步长设置不一致引起的主从不一致。

mysql 异常宕机情况下，如果未设置 sync_binlog=1 或者 innodb_flush_log_at_trx_commit=1 很有可能出现 binlog 或者 relaylog 文件出现损坏，导致主从不一致。

mysql本身的 bug 引起的主从不同步。  

版本不一致，特别是高版本是主，低版本为从的情况下，主数据库上面支持的功能，从数据库上面不支持该功能  


有一个order表，如下，求购买次数最多的两个用户
-------------
```
order_id	user_id	goods
100000	100	苹果
100001	100	苹果
100002	101	橘子
100003	102	苹果
100004	102	香蕉

sql：
SELECT order_id,user_id,COUNT(order_id) AS count FROM order GROUP BY user_id ORDER BY count DESC limit 2
```

事务的特性
-----------
原子性（Atomicity）  
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

一致性（Consistency）  
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。  
拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

隔离性（Isolation）  
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。  

持久性（Durability）  
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。  



事务的隔离级别和高并发  
------------
如果不考虑事务的隔离性，会发生的几种问题：
脏读 (dirty read) ：指在一个事务处理过程里读取了另一个未提交的事务中的数据。

不可重复读 (unrepeated read)：指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

幻读(phantom read)：一个事务执行两次查询，第二次查询比第一次多出或少一些数据，造成两次结果不一致。只是另一个事务在这两次查询中间插入或者删除了数据造成的。  

第一类丢失更新(lost update)： 在完全未隔离事务的情况下，两个事物更新同一条数据资源，某一事物异常终止，回滚造成第一个完成的更新也同时丢失 。

第二类丢失更新(second lost updates)：是不可重复读的特殊情况，如果两个事务都读取同一行，然后两个都进行写操作，并提交，第一个事务所做的改变就会丢失。

四种事务隔离级别：
```
　　1. Serializable 串行化
　　2. Repeatable Read 可重复读
　　3. Read Commited 可读已提交
　　4. Read Uncommited 可读未提交
```

并发控制：
1) 数据库系统采用不同的锁类型来实现以上四种隔离级别，具体的实现过程对用户是透明的。用户应该关心的是如何选择合适的隔离级别。  

2) 对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为 Read Committed，它能够避免脏读，而且具有较好的并发性能。  

3) 每个数据库连接都有一个全局变量 @@tx_isolation ，表示当前的事务隔离级别。JDBC 数据库连接使用数据库系统默认的隔离级别。

4) 在 Hibernate 的配置文件中可以显示地设置隔离级别。每一种隔离级别对应着一个正整数。

5) 需要注意的是，在受管理环境中，如果 Hibernate 使用的数据库连接来自于应用服务器提供的数据源，Hibernate不会改变这些连接的事务隔离级别。在这种情况下，应该通过修改应用服务器的数据源配置来修改隔离级别。

6)当数据库系统采用 Red Committed 隔离级别时，会导致不可重复读和第二类丢失更新的并发问题，在可能出现这种问题的场合。可以在应用程序中采用悲观锁或乐观锁来避免这类问题。

mysql查看当前事务隔离级别：select @@tx_isolation
设置事务隔离级别：set [glogal | session] transaction isolation level 隔离级别名称;或set tx_isolation='隔离级别名称';


悲观锁和乐观锁
-----------
悲观锁
　　正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

　　一个典型的依赖数据库的悲观锁调用：select * from account where name=”Erica” for update这条 sql 语句锁定了 account 表中所有符合检索条件 name=”Erica” ）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。悲观锁，也是基于数据库的锁机制实现。

　　在Hibernate使用悲观锁十分容易，但实际应用中悲观锁是很少被使用的，因为它每次发送的SQL语句都会加上"for update"用于告诉数据库锁定相关数据，大大限制了并发性：

乐观锁
　　相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 "version" 字段来实现。

　　乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。


什么是队列？排它锁，Myisam 死锁如何解决？
-----------
在默认情况下 MYisam 是表级锁，所以同时操作单张表的多个动作只能以队列的方式进行；

排它锁又名写锁，在 SQL 执行过程中为排除其它请求而写锁，在执行完毕后会自动释放；

死锁解决：先找到死锁的线程号，然后杀掉线程 ID


复合索引
------------
概念：用户可以在多个列上建立索引,这种索引叫做复合索引(组合索引); 

复合索引在数据库操作期间所需的开销更小,可以代替多个单一索引; 同时有两个概念叫做窄索引和宽索引,窄索引是指索引列为1-2列的索引,宽索引也就是索引列超过2列的索引; 

设计索引的一个重要原则就是能用窄索引不用宽索引,因为窄索引往往比组合索引更有效;


like 的优化
------------
like写法一般为 select cat from animal where name like %猫% 
用 explain 解释来看 sql 语句并没有运用索引（name 已经创建索引），而是全表扫描。
```
尽量不要使用 like '%..%'

对于 like '..%..' (不以 % 开头)

对于 like '%...' 的 (不以 % 结尾)，加个 reverse 函数，又可以用上索引了'(需要反向索引的支持)SQL> select * from test_like where reverse(object_name)like reverse('%AS');

使用locate函数代替like  
  语法一 LOCATE(substr,str)返回字符串substr中第一次出现子字符串的位置 str。  
  语法二:LOCATE(substr,str,pos)返回 substr 在 str 中第一次出现的位置，如果 substr 在 str 中不存在，返回值为 0 。如果pos存在，返回 substr 在 str 第pos个位置后第一次出现的位置，如果 substr 在 str 中不存在，返回值为0。
```


mysql 优化
-------------
sql 语句优化  
索引优化  
选择合适的存储引擎  
字段选择合适的数据类型  
对表进行水平或者垂直拆分  
针对存储引擎的优化   
磁盘 I/O 优化  
负载均衡  
主从复制  

1）尽量选择较小的列；

2）将where中用的比较频繁的字段建立索引；

3）select中避免使用*；

4）避免在索引列上使用计算、not in和<>等操作；

5）当只需要一行数据时候使用limit1；

6）保证单表数据不超过200w，实时分割表；

针对查询较慢的语句，可以使用explain来分析该语句具体的执行情况。 


索引算法Hash与BTree的区别
-----------
https://blog.csdn.net/kidoo1012/article/details/70207519  
https://blog.csdn.net/u011305680/article/details/55520853  



select * from table where (ID = 10) or (ID = 32) or (ID = 22) or (ID = 76) or (ID = 13) or (ID = 44) 让结果按10，32，22，76，13，44的顺序检索出来,请问如何书写?
------------
```sql
SELECT * FROM `xxxx` WHERE id in (10，32，22，76，13，44) order by field(id, 10，32，22，76，13，44)
```

mysql中删除重复记录，并保留重复数据中的一条数据
------------
假设为admin表
```
# 保留的是id最小的记录  
DELETE FROM `admin` WHERE id NOT IN(SELECT * FROM(SELECT id FROM `admin` GROUP BY username)AS b)
或者
DELETE FROM `admin` WHERE id NOT IN(SELECT * FROM(SELECT min(id) FROM `admin` GROUP BY username) AS b)
```
```
# 保留的是id最大的记录  
DELETE FROM `admin` WHERE id NOT IN(SELECT * FROM(SELECT max(id) FROM `admin` GROUP BY username) AS b)
```

理解：  

先从里面的SQL开始看

1、SELECT id FROM `user` GROUP BY username  根据名字分组查询出每组的ID。  
2、SELECT * FROM(SELECT id FROM `user` GROUP BY username) AS b   

这句话中有2个疑问点：

第一、为什么要套这样一个select？因为更新数据时使用了查询，而查询的数据又做更新的条件，mysql不支持这种方式，如果不套上这个select查询，那么将会报1093 -  You can't specify target table 'user' for update in FROM clause错误。

第二、这句话中一定要取别名，不然会报1248 - Every derived table must have its own alias 错误

3、结合上面的分析来看一下整个的SQL语句理解，先将分组的ID查出来，然后删除USER表中ID 不在分组ID中的数据，那么就实现效果了。
```
delete from 表名 where  ID not in (select * from (select  id from 表名 group by 分组的列名) 别名)  
```

表中有A、B、C三列,用SQL语句实现：当A列大于B列时选择A列否则选择B列，当B列大于C列时选择B列否则选择C列。
---------------
```
select
case
when first_name>middle_name then
case when first_name>last_name then first_name
else last_name end
else
case when middle_name>last_name then middle_name else last_name
end
end as name
from member;

1.用一条sql语句
select (case when a>b then a else b end ),(case when b>c then b esle c end)  from 表名

或者使用

select if(a>b,a,b),if(b>c,b,c) from 表名

select (case when a>b then a
			 when a>c then a
			 when b>c then b else c
			 end) 
from table1
```


内存限制 5m, 文件有 50m, 存的都是整数, 让我求出前 10 个最大的数.
------------


当多表关联查询很慢的时候, 有什么办法加速查询..?
------------
进行多次单表查询, 再程序中合并结果.




1. 什么是表分区?
-----------
表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。

2. 表分区与分表的区别
------------
分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。   分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。  


mysql分区类型
-------------
RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。 

LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择

HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。  

KEY分区：类似Hash分区，Hash分区允许使用用户自定义的表达式，但Key分区不允许使用用户自定义的表达式。Hash仅支持整数分区，而Key分区支持除了Blob和text的其他类型的列作为分区键。  






nosql方面的：
===========

memcache、redis 区别，及应用场景  
-----------
相同点  
1 都是在内存中进行数据的存取
2 都支持k/v的方式存取数据
  
不同点  
1)、数据支持类型
memcache只有string类型的数据。  
Redis不仅仅支持简单的string类型数据，同时还提供list，set，hash等数据结构的存储。

2)、存储方式
Memecache把数据全部存在内存之中，断电后会数据会丢失。
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。  
3）value大小
redis最大可以达到1GB，而memcache只有1MB

4)、使用底层模型不同
它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

总结：
1.Redis使用最佳方式是全部数据in-memory。  
2.Redis更多场景是作为Memcached的替代者来使用。  
3.当需要除key/value之外的更多数据类型支持时，使用Redis更合适。  
4.当存储的数据不能被剔除时，使用Redis更合适。  



MongoDB 优缺点
--------------  
优点  
1、 文档结构的存储方式，能够更便捷的获取数据  
2、 内置 GridFS，支持大容量的存储  
3、 内置 Sharding，分片简单  
4、 海量数据下，性能优越  
5、 支持自动故障恢复（复制集）  

缺点  
1、 不支持事务操作  
2、 占用空间过大  
3、 MongoDB 没有如 MySQL 那样成熟的维护工具  
4、 无法进行关联表查询，不适用于关系多的数据  
5、 复杂聚合操作通过 mapreduce 创建，速度慢  
6、 模式自由，自由灵活的文件存储格式带来的数据错误  


MongoDB 数据类型：
-------------
```
String（字符串）: mongodb 中的字符串是 UTF-8 有效的。
Integer（整数）: 存储数值。整数可以是 32 位或 64 位，具体取决于您的服务器。
Boolean（布尔）: 存储布尔( true/false )值。

Double（双精度）: 存储浮点值。
Min/ Max keys（最小/最大键）: 将值与最低和最高 BSON 元素进行比较。
Arrays（数组）: 将数组或列表或多个值存储到一个键中。
Timestamp（时间戳）: 存储时间戳。
Object（对象）: 嵌入式文档。
Null （空值）: 存储 Null 值。
Symbol（符号）: 与字符串相同，用于具有特定符号类型的语言。
Date（日期）: 以 UNIX 时间格式存储当前日期或时间。
Object ID（对象ID） : 存储文档 ID。
Binary data（二进制数据）: 存储二进制数据。
Code（代码）: 将 JavaScript 代码存储到文档中。
Regular expression（正则表达式）: 存储正则表达式
```








